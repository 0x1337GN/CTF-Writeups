# Snake Eater II

### Challenge Description
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/77d42001-12af-4568-be33-2158e1df9c39)

### Solution
Running the malware binary in a segregated Windows VM for some dynamic analysis, we find that it writes the flag into a flag.txt file under the /AppData/Roaming folders. Running it several times, we can notice it is randomly assigned a location. 
This all happens very quickly, within the same second the file gets created, the flag written in it and then deleted. I struggled using IDA to set breakpoints before it gets deleted but failed.

If I couldn't stop the deletion, my idea then shifted towards catching the flag before it gets deleted. To narrow the possibilities of where it could be wrriten, I moved out all of the folders that I could from the Roaming folder until I was left only with the Microsoft folder.

Then I ran the binary in a while loop to write the flag continuously:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/00ec323b-8d30-462d-90c0-f6bab3a61457)

I then wrote this powershell script to continuously try and read the flag from a specific location:  

```powershell
$sourceDirectory = "c:\users\commandovm\appdata\roaming\microsoft\"
$fileToSearch = "flag.txt"

while ($true) {
    $sourceFile = Join-Path -Path $sourceDirectory -ChildPath $fileToSearch

    if (Test-Path $sourceFile) {
        $flag = Get-Content $sourceFile
        Write-Host "Flag is $flag"
    }

}
```
The idea here being that eventually, the flag will be written where I wanted and a collision will happen. Luckily enough, after a short while I indeed got the flag printed to the screen.  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/e4df8819-a129-478c-8b05-b6b0bfde5723)

Funnily enough, you can even see where above it, the script tried to read the created file before the flag was even written to it.

flag{be47387ab77251ecf80db1b6725dd7ac}
