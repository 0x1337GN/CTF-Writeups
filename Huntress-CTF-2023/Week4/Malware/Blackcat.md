# Blackcat

### Challenge Description
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/3299047f-8a89-4cc4-ab48-2ee2eab2afd8)

### Solution
After we decompressed the archive, we can see the files are encrypted by a ransomware. There's a binary file as well:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/556c70de-994e-4c33-aa24-5e5463f00daa)

Running it, it asks for a ransomware key. If we input one character, it says it's too small. If we input something longer, it doesn't say anything and just exits out:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/ce8eb3d1-3ae9-49ce-b6d5-55953c0946cc)

We decompile the binary and in the main function I found that it's comparing 8 characters and then it jumps to another function if it is equal or greater than 8.  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/f7037625-e1a5-43a5-b068-04b857b95be8)

I patched this function using Ghidra and made it jump if the result is less than 8:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/4148a260-4d6c-4aae-aa82-86603b9856cd)

Now when we run the binary again, after we copy the flag into the victim-files folder, we can see it decrypted it:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/9f3c8d71-35e3-4ba3-aeef-6f1ba8b579f6)

But when we read it, it still seems encrypted, just differently:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/aeb67469-18fa-47ce-889f-eb103fe0de98)

I tried a lot of ways to bruteforce this but with no result. Considering we also have the hamlet text, we should be able to figure this out in a different way. I used the [xortool](https://github.com/hellman/xortool) to find the most probable key given the space as the most common character. I passed the decrypted version of the hamlet text and got some bytes and the information that the most probable key length is 8. This would match the number we saw in Ghidra so I thought I'm on the right track:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/cdbdbdfa-8e5d-4366-8f2b-1555827c5857)

I converted these bytes into hex:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/7ba6572d-6663-417d-9575-6a16a7cc4981)

And then used Cyberchef to try and unXOR it, after removing the 0a at the end to keep just the first 8 bytes I got this:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/57f75e23-1edb-485b-92ab-d1e65c18d790)

This partial text made me believe I was on the right track and got stuck here for a while. I even tried bruteforcing two bytes at a time as it was faster, in different combinations but ended up nowhere. Then I thought to use the `xortool` directly on the encrypted version of the hamlet text and I was surprised to see that I actually got a plaintext key:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/e174a92f-ffad-4b1d-b7e2-2f6a144fd5d6)

With the `cosmoboi` key, I was able to unXOR the originally .encry flag file and get the flag:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/77d04fbe-7027-4fdb-8d5d-e41d2ec5dae4)

We can also pass the key into the decryption binary and it successfully decrypts it:  
![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/daa0a0c3-373b-46fd-8d4f-bf3f2c784581)

![image](https://github.com/LazyTitan33/CTF-Writeups/assets/80063008/833dd662-6519-4a3c-ae38-489c5f28b1e9)

Lessons learned: Sometimes bruteforcing is the way to go instead of RE.

flag{092744b55420033c5eb9d609eac5e823}
